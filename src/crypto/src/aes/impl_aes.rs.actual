use aes_gcm::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Aes256Gcm, Key, Nonce,
};

use crate::error::CryptoError;
use crate::utils;

/// AES-256-GCM cipher for authenticated encryption
pub struct AesGcm {
    cipher: Aes256Gcm,
}

impl AesGcm {
    /// Create a new AES-GCM cipher with the given key
    ///
    /// # Arguments
    ///
    /// * `key` - A 32-byte key (e.g., from Kyber KEM)
    ///
    /// # Returns
    ///
    /// A new AesGcm cipher or an error
    pub fn new(key: &[u8]) -> Result<Self, CryptoError> {
        if key.len() != 32 {
            return Err(CryptoError::InvalidParameterError(format!(
                "AES-256-GCM requires a 32-byte key, got {}",
                key.len()
            )));
        }

        let key = Key::<Aes256Gcm>::from_slice(key);
        let cipher = Aes256Gcm::new(key);

        Ok(Self { cipher })
    }

    /// Generate a random nonce for encryption
    ///
    /// # Returns
    ///
    /// A 12-byte nonce
    pub fn generate_nonce() -> Vec<u8> {
        Aes256Gcm::generate_nonce(&mut OsRng).to_vec()
    }

    /// Encrypt plaintext using AES-GCM
    ///
    /// # Arguments
    ///
    /// * `plaintext` - The data to encrypt
    /// * `nonce` - A 12-byte nonce (should be unique for each encryption)
    /// * `associated_data` - Additional data to authenticate but not encrypt
    ///
    /// # Returns
    ///
    /// The encrypted ciphertext or an error
    pub fn encrypt(&self, plaintext: &[u8], nonce: &[u8], associated_data: &[u8]) -> Result<Vec<u8>, CryptoError> {
        if nonce.len() != 12 {
            return Err(CryptoError::InvalidParameterError(format!(
                "AES-GCM nonce must be 12 bytes, got {}",
                nonce.len()
            )));
        }

        let nonce = Nonce::from_slice(nonce);
        
        // Concatenate plaintext and associated data
        let mut plaintext_with_aad = plaintext.to_vec();
        plaintext_with_aad.extend_from_slice(associated_data);
        
        self.cipher.encrypt(nonce, plaintext_with_aad.as_ref())
            .map_err(|e| CryptoError::EncryptionError(e.to_string()))
    }

    /// Decrypt ciphertext using AES-GCM
    ///
    /// # Arguments
    ///
    /// * `ciphertext` - The encrypted data
    /// * `nonce` - The same 12-byte nonce used for encryption
    /// * `associated_data` - The same additional data used for encryption
    ///
    /// # Returns
    ///
    /// The decrypted plaintext or an error
    pub fn decrypt(&self, ciphertext: &[u8], nonce: &[u8], associated_data: &[u8]) -> Result<Vec<u8>, CryptoError> {
        if nonce.len() != 12 {
            return Err(CryptoError::InvalidParameterError(format!(
                "AES-GCM nonce must be 12 bytes, got {}",
                nonce.len()
            )));
        }

        let nonce = Nonce::from_slice(nonce);
        
        let plaintext_with_aad = self.cipher.decrypt(nonce, ciphertext.as_ref())
            .map_err(|e| CryptoError::DecryptionError(e.to_string()))?;
            
        // Remove the associated data from the end
        if plaintext_with_aad.len() < associated_data.len() {
            return Err(CryptoError::DecryptionError(
                "Decrypted data too short to contain associated data".to_string()
            ));
        }
        
        let plaintext_len = plaintext_with_aad.len() - associated_data.len();
        let plaintext = plaintext_with_aad[..plaintext_len].to_vec();
        
        Ok(plaintext)
    }
}

/// Convenience function to encrypt data using AES-GCM
///
/// # Arguments
///
/// * `plaintext` - The data to encrypt
/// * `key` - A 32-byte key (e.g., from Kyber KEM)
/// * `associated_data` - Additional data to authenticate
///
/// # Returns
///
/// A tuple containing (ciphertext, nonce) or an error
pub fn encrypt(plaintext: &[u8], key: &[u8], associated_data: &[u8]) -> Result<(Vec<u8>, Vec<u8>), CryptoError> {
    let cipher = AesGcm::new(key)?;
    let nonce = AesGcm::generate_nonce();
    let ciphertext = cipher.encrypt(plaintext, &nonce, associated_data)?;
    Ok((ciphertext, nonce))
}

/// Convenience function to decrypt data using AES-GCM
///
/// # Arguments
///
/// * `ciphertext` - The encrypted data
/// * `key` - The same 32-byte key used for encryption
/// * `nonce` - The same nonce used for encryption
/// * `associated_data` - The same additional data used for encryption
///
/// # Returns
///
/// The decrypted plaintext or an error
pub fn decrypt(ciphertext: &[u8], key: &[u8], nonce: &[u8], associated_data: &[u8]) -> Result<Vec<u8>, CryptoError> {
    let cipher = AesGcm::new(key)?;
    cipher.decrypt(ciphertext, nonce, associated_data)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_aes_gcm_encrypt_decrypt() {
        let key = utils::random_bytes(32).unwrap();
        let plaintext = b"This is a test message for encryption";
        let associated_data = b"additional authenticated data";

        // Encrypt
        let (ciphertext, nonce) = encrypt(plaintext, &key, associated_data).unwrap();

        // Verify ciphertext is not the same as plaintext
        assert_ne!(&ciphertext, plaintext);

        // Decrypt
        let decrypted = decrypt(&ciphertext, &key, &nonce, associated_data).unwrap();

        // Verify decryption worked
        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_aes_gcm_invalid_nonce() {
        let key = utils::random_bytes(32).unwrap();
        let cipher = AesGcm::new(&key).unwrap();
        let plaintext = b"This is a test message";
        let invalid_nonce = vec![0; 10]; // Too short

        let result = cipher.encrypt(plaintext, &invalid_nonce, b"");
        assert!(result.is_err());
    }

    #[test]
    fn test_aes_gcm_invalid_key() {
        let key = utils::random_bytes(16).unwrap(); // Too short for AES-256
        let result = AesGcm::new(&key);
        assert!(result.is_err());
    }

    #[test]
    fn test_aes_gcm_tampered_ciphertext() {
        let key = utils::random_bytes(32).unwrap();
        let plaintext = b"This is a test message for tamper detection";
        let associated_data = b"additional data";

        // Encrypt
        let (mut ciphertext, nonce) = encrypt(plaintext, &key, associated_data).unwrap();

        // Tamper with the ciphertext
        if !ciphertext.is_empty() {
            ciphertext[0] ^= 0x01;
        }

        // Try to decrypt
        let result = decrypt(&ciphertext, &key, &nonce, associated_data);
        assert!(result.is_err());
    }

    #[test]
    fn test_aes_gcm_wrong_key() {
        let key1 = utils::random_bytes(32).unwrap();
        let key2 = utils::random_bytes(32).unwrap();
        let plaintext = b"This is a test message for wrong key";

        // Encrypt with key1
        let (ciphertext, nonce) = encrypt(plaintext, &key1, b"").unwrap();

        // Try to decrypt with key2
        let result = decrypt(&ciphertext, &key2, &nonce, b"");
        assert!(result.is_err());
    }

    #[test]
    fn test_with_empty_associated_data() {
        let key = utils::random_bytes(32).unwrap();
        let plaintext = b"Test message with empty AAD";
        let associated_data = b"";

        let (ciphertext, nonce) = encrypt(plaintext, &key, associated_data).unwrap();
        let decrypted = decrypt(&ciphertext, &key, &nonce, associated_data).unwrap();

        assert_eq!(decrypted, plaintext);
    }

    #[test]
    fn test_with_large_data() {
        let key = utils::random_bytes(32).unwrap();
        let plaintext = vec![0xAA; 1000]; // 1KB of data
        let associated_data = b"large data test";

        let (ciphertext, nonce) = encrypt(&plaintext, &key, associated_data).unwrap();
        let decrypted = decrypt(&ciphertext, &key, &nonce, associated_data).unwrap();

        assert_eq!(decrypted, plaintext);
    }
} 